<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>Rasterizer</h1>
		<div style="text-align: center;">Names: Stephane Finot</div>

			<!--
			I've already added one heading per task to make the write-up navigable when grading.
			-->

		<h2>Overview</h2>
			<p>In this assignment, I created a basic rasterizer pipeline to handle drawing triangles, texture mapping, antialiasing, and hierarchical transformations. For texture mapping, I implemented Barycentric Coordinates to interpolate between vertices with different color values. This also enabled handling UV mapping to add textures. To further refine texture sampling, I added pixel sampling and level sampling to gain more accurate results with different-sized frame buffers. Supersampling helped with aliasing across these operations. With this pipeline, I could render SVG files with controllable sample rates and pixel sampling methods.</p>
			<p>It was interesting to decide how to handle different parts of the pipeline, as well as how they all worked synchronously in the end.</p>


			<h2>Task 1: Drawing Single-Color Triangles</h2>
			<p>The first step to rasterizing triangles was to order the vertices of the triangle to be in counterclockwise order to establish a consistent direction for future computation. Next, I iterated over each pixel within the bounding box of the triangle. Using dot product operations, I determined whether a point is in the direction of a line's normal vector. Due to the prior ordering of vertices, if all the dot products are positive, then the point is in the triangle and can be drawn.</p>
			The algorithm is no worse than checking each sample within the bounding box of the triangle because it does not check samples beyond the bounding box.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task1.png" width="400px"/>
				  <figcaption>Basic Triangles</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
			<p>For supersampling, I no longer sampled only once per pixel. Instead, I sampled smaller subpixels within each pixel of the frame buffer and stored that data in a larger sample buffer scaled by the sample rate. Within this larger sample buffer, I averaged the color values of the subpixels to determine the color of a full pixel in the original frame buffer.</p>
			<p>Supersampling is useful because it depicts higher frequencies by allowing more samples to be represented in the rasterization. This helps reduce aliasing like the <q>jaggies</q> apparent in triangles (see Sample rate 1 image). If only a corner of a pixel is covered and only one sample is taken, it may not show in the frame buffer. With supersampling, the covered corner is represented by its weight in the average used to compute the pixel color. I increased the sample rate to get a smooth display in the triangles, as seen in the results.</p>
			<p>One design decision I considered was scaling all the given data before performing calculations and triangle processing, but I determined that this method would be more inefficient and more difficult to use with other features.</p>

			<p>Comparing difference sample rates:</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task2_1sample.png" width="400px"/>
							<figcaption>Sample rate 1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task2_4sample.png" width="400px"/>
							<figcaption>Sample rate 4</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task2_16sample.png" width="400px"/>
							<figcaption>Sample rate 16</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h2>Task 3: Transforms</h2>
			With hierarchical transforms, I tried to make this cubeman wave at the viewer. Adding subtle bends and leaning makes the pose more natural.
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/my_robot.png" width="400px"/>
							<figcaption>Robot</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h2>Task 4: Barycentric Coordinates</h2>
			Barycentric Coordinates are a coordinate system used to determine the position of a point in a triangle relative to its vertices. By measuring the distance between a point and each vertex, one can find the relative weights for each vertex. This is useful for interpolating values across the triangle: multiply the vertex values by their weight at a point to obtain a continuous function across the triangle. In the colored triangle below, each vertex was colored red, green, or blue. The distance from each vertex dictates the color. For example, moving along the line from the red vertex to the blue vertex, the points do not have any green because the green vertex is on the opposite side of the triangle and has a weight of 0.
			<p>Examples of using Barycentric Coordinates.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task4.png" width="400px"/>
							<figcaption>Color Wheel</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task4_triangle.png" width="400px"/>
							<figcaption>Colored Triangle</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
			<p>Pixel sampling is the process of turning the source data of textures into one full pixel on the frame buffer. For instance, if there are many colors within one pixel's space, the pixel-sampling method determines how to represent that information in the pixel. I implemented pixel sampling by taking the Barycentric Coordinates of the point in the frame buffer to the corresponding Barycentric coordinates in the UV space. This provides a mapping from UV space to the frame buffer.</p>
			<p>With nearest sampling, the sample is taken from the closest point in UV space. Bilinear sampling takes the nearest four points and interpolates between them by finding a weighted sum based on the distance to each point to form the final returned value.</p>
			<p>Bilinear sampling generally appears smoother due to its interpolation of nearby pixels. There will be a larger difference between the two when the texture resolution is greater than the frame buffer because the nearest sampling method will lose more data by only being able to represent a quarter of the points that bilinear sampling can represent.</p>

			<p>Below, the comparison shows nearest and bilinear sampling at 1 and 16 sample rates. Some of the most visible differences are image smoothness and small details like longitude lines and the brown coast at the center of the pixel viewer.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/t5_nearest_1sample.png" width="400px"/>
							<figcaption>Nearest interpolation: 1 sample</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/t5_nearest_16sample.png" width="400px"/>
							<figcaption>Nearest interpolation: 16 samples</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/t5_bilinear_1sample.png" width="400px"/>
							<figcaption>Bilinear interpolation: 1 sample</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/t5_bilinear_16sample.png" width="400px"/>
							<figcaption>Bilinear interpolation: 16 samples</figcaption>
						</td>
					</tr>
				</table>
			</div>


			<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
			<p>Level sampling is a method of reducing computational load and aliasing by displaying lower-resolution textures at further distances. I achieve this by storing copies of the original texture at decreasing resolutions in a mipmap. When sampling a point at the original resolution, I calculate the distance from the viewer by taking the Barycentric coordinates of points A, B, and C. A represents the original point, B is one pixel up from A, and C is one pixel to the right of A. With these Barycentric coordinates, I find the corresponding positions in UV space and compute the distance between AB and AC. With that distance, I scale it by the size of the original resolution and take log2 to get the desired mip distance float. With the mip distance float, I can use nearest level sampling by taking the color value at the nearest stored mip level, or bilinear level sampling, which interpolates between the corresponding values in the two nearest mip levels.</p>
			<p>Combining level sampling with pixel sampling and supersampling provides many features with different tradeoffs. Level sampling is the fastest because it provides instant access to pre-antialiased textures and avoids handling high-resolution textures for distant objects. However, this requires more storage (roughly 33% more) for the mipmaps. Nearest level sampling is the fastest but less accurate in antialiasing than bilinear level sampling.</p>
			<p>Nearest pixel sampling is fast, as it samples one point, but it does not provide antialiasing. Bilinear pixel sampling and supersampling provide antialiasing but require more operations and are therefore slower.</p>
			<p>See below for a comparison of different parameters.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/t60near.png" width="400px"/>
							<figcaption>Zero Level, Nearest Pixel Sampling</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/t60bi.png" width="400px"/>
							<figcaption>Zero Level, Bilinear Pixel Sampling</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/t6nearnear.png" width="400px"/>
							<figcaption>Nearest Level, Nearest Pixel Sampling</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/t6nearbi.png" width="400px"/>
							<figcaption>Nearest Level, Bilinear Pixel Sampling</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<p> Zero level sampling has greater contrast and more defined lines, but suffers from jaggies. Nearest level sampling provides a more continuous form at the cost of sharpness. Bilinear pixel sampling smooths both of them. </p>
