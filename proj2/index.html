<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>Mesh Operations</h1>
		<div style="text-align: center;">Names: Stephane Finot</div>


		<h2>Overview</h2>
			<p>In this assignment, I implemented de Casteljau's algorithm to construct Bezier curves from given control points and extended that curve function to determine Bezier surfaces. I also created a mesh editor to enable basic operations, including edge flips, edge splits, and loop subdivisions across solid meshes and boundaries. By calculating area-weighted normals, I used Phong shading for a smooth render. With these operations, I could import custom meshes from external programs like Blender and edit them in my program. Overall, the levels of abstraction in the edge operations were interesting to work with, and I learned to be cautious when working with topology and meshes.</p>

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
			<p>De Casteljau's algorithm is a process for determining a continuous curve formed by a set of control points. I implemented de Casteljau's algorithm by interpolating between a list of control points given an input parameter t. A new point, between two old points, can be found with the equation p1 * t - p2 * (1 - t). Each linear interpolation between N control points results in a new set of N-1 points. I repeated this process until producing one point that lies on the curve.</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="images/task10.png" width="350px"/>
				  <figcaption>Control Points</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="images/task11.png" width="350px"/>
				  <figcaption>Iteration 1</figcaption>
				</td>
				  <td style="text-align: center;">
					  <img src="images/task12.png" width="350px"/>
					  <figcaption>Iteration 2</figcaption>
				  </td>
				  <td style="text-align: center;">
					  <img src="images/task13.png" width="350px"/>
					  <figcaption>Iteration 3</figcaption>
				  </td>
			  </tr>
			  <tr>
				  <td style="text-align: center;">
					  <img src="images/task14.png" width="350px"/>
					  <figcaption>Iteration 4</figcaption>
				  </td>
				  <td style="text-align: center;">
					  <img src="images/task15lastpoint.png" width="350px"/>
					  <figcaption>Final iteration for a point</figcaption>
				  </td>
				  <td style="text-align: center;">
					  <img src="images/task16withcurve.png" width="350px"/>
					  <figcaption>Full curve drawn</figcaption>
				  </td>
				  <td style="text-align: center;">
					  <img src="images/task17shiftedt.png" width="350px"/>
					  <figcaption>Shifted control points and t-value</figcaption>
				  </td>
			  </tr>
			</table>
		</div>
			<p>The last image has a greater t-value, which can be seen by the intermediate points lying further up each line.</p>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
			<p>To generate a Bezier surface, I formed curves between rows of points with de Casteljau's algorithm and then interpolated between the corresponding points on the newly formed curves to create the surface. I implemented Bezier surfaces by taking an NxN grid of points and U and V parameters. By running de Casteljau's algorithm on each row of points with U as input, I obtained a point at the U-value along the curve of each row. Between these U-points, I defined a new curve using V as input to get the final point at the desired UV coordinates on the grid.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task2smooth.png" width="600"/>
							<figcaption>Mesh View</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task2wireframe.png" width="600"/>
							<figcaption>Wireframe View</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
			<p>I implemented area-weighted vertex normals by iterating around a given vertex to get the opposing points of each face that the original vertex is connected to. Next, I formed vectors between the original vertex and the surrounding vertices to calculate the normal of each surrounding face via a cross product. The output vector indicates the normal's direction and has magnitude equal to the face area, so summing the cross products yields a vertex normal weighted by surrounding face areas. Finally, I normalized the vertex normal by dividing the vector by its magnitude.</p>

			<p>With area-weighted vertex normals, I can implement Phong shading for a smoother appearance without needing to increase geometry.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task2noShade.png" width="600"/>
							<figcaption>Without Phong Shading</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task2Shade.png" width="600"/>
							<figcaption>With Phong Shading enabled</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h3>Part 4: Edge flip</h3>
			<p>I implemented the edge flip operation by first storing all of the halfedges as local variables to avoid losing them during pointer reassignment. Next, I updated the next pointers of each halfedge to match the new triangles formed by the flip. Then, I reassigned the faces of two halfedges, as only two will have face changes in a two-triangle setup. Lastly, I reassigned the vertices of the flipped halfedges and returned the input iterator.</p>

			<p>One interesting observation is that the teapot is geometrically formed by quads split into triangles. If I edge-flip the edge that crosses a quad, the geometry does not change. However, flipping an edge between two quads deforms the geometry, as seen in the images below.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task4preflip.png" width="600"/>
							<figcaption>Teapot before edge flips</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task4postflip.png" width="600"/>
							<figcaption>Teapot after edge flips</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h3>Part 5: Edge split</h3>
			<p>Similar to the edge flip operation, I implemented edge split by first storing all the halfedges, vertices, faces, and edges as local variables. Next, I created 3 new edges, 6 new halfedges, 2 new faces, and a new vertex, storing them in variables. With every halfedge, edge, face, and vertex stored in pointers, I connected them in the desired order to create a proper edge split. Finally, I set the position of the new vertex to the average of its edge's endpoints and returned it. Drawing the entire process helped significantly in tracking every component.</p>

			<p>I noticed that after splitting an edge, you should not flip any edges that resulted from the split. Otherwise, the edge being flipped will share the same vertices with another edge and may seem to disappear.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task5preSplit.png" width="600"/>
							<figcaption>Teapot before edge splits</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task5postSplit.png" width="600"/>
							<figcaption>Teapot after edge splits</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/task5preSplitFlips.png" width="600"/>
							<figcaption>Teapot before splits and flips</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task5postSplitFlips.png" width="600"/>
							<figcaption>Teapot after splits and flips</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<h3>Part 5: Boundary edge splits</h3>
			<p>To account for boundary edges, I first check if the edge is on a boundary before performing any operations. If splitting a boundary edge, I create 2 new edges, 4 new halfedges, 1 new face, and a new vertex. Next, I reassign everything similarly to a non-boundary edge while omitting the boundary side. One issue I faced was the Halfedge implementation, as halfedges do not have a boundary attribute. I had to store the original halfedge's face and assign that as the face of the newly created halfedges to ensure the isBoundary() function returns true for future operations. After all assignments are complete, I compute and assign the vertex position and return the vertex iterator.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task5ecPre.png" width="600"/>
							<figcaption>Before edge splits and flips</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task5ecPost.png" width="600"/>
							<figcaption>After edge splits and flips</figcaption>
						</td>
					</tr>
				</table>
			</div>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
			<p>I implemented loop subdivision by first iterating through every vertex and storing the new positions of each vertex after subdivision. I also saved the location of the new vertex that will be formed by each split and stored it in the edge. Next, I split every edge and set the new vertex to the stored position. To avoid infinite loops, I ensured that only old edges were split. Then I flipped every edge that connected an old vertex to a new vertex to produce a consistent subdivision pattern. Finally, I shifted all old vertices to their new locations.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task6pot1.png" width="350"/>
							<figcaption>Teapot</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6pot2.png" width="350"/>
							<figcaption>Teapot after subdivision</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cow1.png" width="350"/>
							<figcaption>Cow</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cow2.png" width="350"/>
							<figcaption>Cow after subdivision</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h3>Part 6: Sharp Edges and Corners</h3>
			<p>I observed that meshes lose sharp corners if there is a lack of geometry. By pre-splitting edges, corners and edges are less deformed because the surrounding vertices that influence the original vertex's new position are closer. This results in corner vertices moving less.</p>

			<p>In the images below, I repeatedly split edges towards the top right corner. As seen, the corner remains much sharper than the other corners that were not split.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task6subs1.png" width="350"/>
							<figcaption>Original Mesh</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6subs2.png" width="350"/>
							<figcaption>Subdivision 1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6subs3.png" width="350"/>
							<figcaption>Subdivision 2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6subs4.png" width="350"/>
							<figcaption>Subdivision 3</figcaption>
						</td>
					</tr>
				</table>
			</div>

			<h3>Part 6: Cube Asymmetry</h3>

			<p>A basic cube will subdivide asymmetrically because of how the triangles are formed on each face. Some corners are at higher degrees than others, meaning they will deform differently according to the subdivision rules. By splitting edges on faces to ensure each face is consistent, the topology becomes more uniform and the asymmetric output is reduced. When every corner vertex is of the same degree, they will deform in the same way.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task6cubeD1.png" width="350px"/>
							<figcaption>Original</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeD2.png" width="350px"/>
							<figcaption>Subdivision 1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeD3.png" width="350px"/>
							<figcaption>Subdivision 2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeD4.png" width="350px"/>
							<figcaption>Subdivision 3</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="images/task6cubeS1.png" width="350px"/>
							<figcaption>Original with splits</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeS2.png" width="350px"/>
							<figcaption>Subdivision 1</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeS3.png" width="350px"/>
							<figcaption>Subdivision 2</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6cubeS4.png" width="350px"/>
							<figcaption>Subdivision 3</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<h3>Part 6: Boundary Edge Split</h3>
			<p>I implemented boundary support for mesh upsampling via loop subdivision. I updated vertex positions for boundary vertices and, for edges on the boundary, implemented new vertex weighting for e->newPosition.</p>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/task6ec.png" width="600"/>
							<figcaption>Boundary before subdivision</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/task6ec2.png" width="600"/>
							<figcaption>Boundary after subdivision</figcaption>
						</td>
					</tr>
				</table>
			</div>


		</div>
	</body>
</html>
